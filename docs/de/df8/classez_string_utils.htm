<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ezEngine: ezStringUtils Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../EZ-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ezEngine
   &#160;<span id="projectnumber">Release 21.10</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.htm','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('de/df8/classez_string_utils.htm','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="../../d1/db5/classez_string_utils-members.htm">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ezStringUtils Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Helper functions to work with UTF-8 strings (which include pure ASCII strings)  
 <a href="../../de/df8/classez_string_utils.htm#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../de/dde/_string_utils_8h_source.htm">StringUtils.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a30a256e58c74618a988775c15bdd3d8e"><td class="memItemLeft" align="right" valign="top"><a id="a30a256e58c74618a988775c15bdd3d8e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#a30a256e58c74618a988775c15bdd3d8e">EZ_CHARACTER_FILTER</a> = bool(*)(ezUInt32 uiChar)</td></tr>
<tr class="memdesc:a30a256e58c74618a988775c15bdd3d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Definition for a function that determines whether a (Utf32) character belongs to a certain category of characters. <br /></td></tr>
<tr class="separator:a30a256e58c74618a988775c15bdd3d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a38c06da943ab13d9183ea38553e02279"><td class="memTemplParams" colspan="2"><a id="a38c06da943ab13d9183ea38553e02279"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a38c06da943ab13d9183ea38553e02279"><td class="memTemplItemLeft" align="right" valign="top">constexpr EZ_ALWAYS_INLINE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IsNullOrEmpty</b> (const T *pString)</td></tr>
<tr class="separator:a38c06da943ab13d9183ea38553e02279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d31f41c458c3fb66f57efbd3b26395"><td class="memTemplParams" colspan="2"><a id="a57d31f41c458c3fb66f57efbd3b26395"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a57d31f41c458c3fb66f57efbd3b26395"><td class="memTemplItemLeft" align="right" valign="top">EZ_ALWAYS_INLINE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IsNullOrEmpty</b> (const T *pString, const T *pStringEnd)</td></tr>
<tr class="separator:a57d31f41c458c3fb66f57efbd3b26395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95d3e57af17f15b82c099f5f0bd88a2"><td class="memTemplParams" colspan="2"><a id="ad95d3e57af17f15b82c099f5f0bd88a2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad95d3e57af17f15b82c099f5f0bd88a2"><td class="memTemplItemLeft" align="right" valign="top">EZ_ALWAYS_INLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>UpdateStringEnd</b> (const T *szStringStart, const T *&amp;szStringEnd)</td></tr>
<tr class="separator:ad95d3e57af17f15b82c099f5f0bd88a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a26f868ce8249b864f448837638ffde33"><td class="memTemplParams" colspan="2"><a id="a26f868ce8249b864f448837638ffde33"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a26f868ce8249b864f448837638ffde33"><td class="memTemplItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#a26f868ce8249b864f448837638ffde33">IsNullOrEmpty</a> (const T *pString)</td></tr>
<tr class="memdesc:a26f868ce8249b864f448837638ffde33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the given string is a nullptr pointer or a string that immediately terminates with a '\0' character. <br /></td></tr>
<tr class="separator:a26f868ce8249b864f448837638ffde33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1ea5471748e08328b7d68f07ea70f0"><td class="memTemplParams" colspan="2"><a id="abb1ea5471748e08328b7d68f07ea70f0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abb1ea5471748e08328b7d68f07ea70f0"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#abb1ea5471748e08328b7d68f07ea70f0">IsNullOrEmpty</a> (const T *pString, const T *pStringEnd)</td></tr>
<tr class="memdesc:abb1ea5471748e08328b7d68f07ea70f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the given string is a nullptr pointer, is equal to its end or a string that immediately terminates with a '\0' character. <br /></td></tr>
<tr class="separator:abb1ea5471748e08328b7d68f07ea70f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc147fa26ed4756b3d21a3adca10fe38"><td class="memTemplParams" colspan="2"><a id="afc147fa26ed4756b3d21a3adca10fe38"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afc147fa26ed4756b3d21a3adca10fe38"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#afc147fa26ed4756b3d21a3adca10fe38">UpdateStringEnd</a> (const T *szStringStart, const T *&amp;szStringEnd)</td></tr>
<tr class="memdesc:afc147fa26ed4756b3d21a3adca10fe38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recomputes the end pointer of a string (<em>szStringEnd</em>), if that is currently set to ezMaxStringEnd. Otherwise does nothing. <br /></td></tr>
<tr class="separator:afc147fa26ed4756b3d21a3adca10fe38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50e765fba05ee2f920e3334982eb352"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac50e765fba05ee2f920e3334982eb352"><td class="memTemplItemLeft" align="right" valign="top">static constexpr ezUInt32&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#ac50e765fba05ee2f920e3334982eb352">GetStringElementCount</a> (const T *pString)</td></tr>
<tr class="memdesc:ac50e765fba05ee2f920e3334982eb352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements of type T that the string contains, until it hits an element that is zero OR until it hits the end pointer.  <a href="../../de/df8/classez_string_utils.htm#ac50e765fba05ee2f920e3334982eb352">More...</a><br /></td></tr>
<tr class="separator:ac50e765fba05ee2f920e3334982eb352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dfad40f09f4815168a05bfd5ed65242"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4dfad40f09f4815168a05bfd5ed65242"><td class="memTemplItemLeft" align="right" valign="top">static ezUInt32&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#a4dfad40f09f4815168a05bfd5ed65242">GetStringElementCount</a> (const T *pString, const T *pStringEnd)</td></tr>
<tr class="memdesc:a4dfad40f09f4815168a05bfd5ed65242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements of type T that the string contains, until it hits an element that is zero OR until it hits the end pointer.  <a href="../../de/df8/classez_string_utils.htm#a4dfad40f09f4815168a05bfd5ed65242">More...</a><br /></td></tr>
<tr class="separator:a4dfad40f09f4815168a05bfd5ed65242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1825871aad703fcbda09e6a5f96eb40b"><td class="memItemLeft" align="right" valign="top"><a id="a1825871aad703fcbda09e6a5f96eb40b"></a>
static ezUInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#a1825871aad703fcbda09e6a5f96eb40b">GetCharacterCount</a> (const char *szUtf8, const char *pStringEnd=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a1825871aad703fcbda09e6a5f96eb40b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of characters (not Bytes!) in a Utf8 string (excluding the zero terminator), until it hits zero or the end pointer. <br /></td></tr>
<tr class="separator:a1825871aad703fcbda09e6a5f96eb40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab532b377c25c3a38b0c7988527ece960"><td class="memItemLeft" align="right" valign="top"><a id="ab532b377c25c3a38b0c7988527ece960"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#ab532b377c25c3a38b0c7988527ece960">GetCharacterAndElementCount</a> (const char *szUtf8, ezUInt32 &amp;uiCharacterCount, ezUInt32 &amp;uiElementCount, const char *pStringEnd=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:ab532b377c25c3a38b0c7988527ece960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns both the number of characters and the number of bytes in a Utf8 string, until it hits zero or the end pointer. <br /></td></tr>
<tr class="separator:ab532b377c25c3a38b0c7988527ece960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193ae00236c80eb4aa25942bcc2d71d2"><td class="memItemLeft" align="right" valign="top">static ezUInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#a193ae00236c80eb4aa25942bcc2d71d2">Copy</a> (char *szDest, ezUInt32 uiDstSize, const char *szSource, const char *pSourceEnd=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a193ae00236c80eb4aa25942bcc2d71d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the string from szSource into the given buffer, which can hold at least uiDstSize bytes.  <a href="../../de/df8/classez_string_utils.htm#a193ae00236c80eb4aa25942bcc2d71d2">More...</a><br /></td></tr>
<tr class="separator:a193ae00236c80eb4aa25942bcc2d71d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586a009ed403d13479d284f3d1ef0f7f"><td class="memItemLeft" align="right" valign="top">static ezUInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#a586a009ed403d13479d284f3d1ef0f7f">CopyN</a> (char *szDest, ezUInt32 uiDstSize, const char *szSource, ezUInt32 uiCharsToCopy, const char *pSourceEnd=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a586a009ed403d13479d284f3d1ef0f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies up to uiCharsToCopy characters into the given buffer, which can hold at least uiDstSize bytes.  <a href="../../de/df8/classez_string_utils.htm#a586a009ed403d13479d284f3d1ef0f7f">More...</a><br /></td></tr>
<tr class="separator:a586a009ed403d13479d284f3d1ef0f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee76481bb274c71041c0cc03cdc37188"><td class="memItemLeft" align="right" valign="top"><a id="aee76481bb274c71041c0cc03cdc37188"></a>
static ezUInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#aee76481bb274c71041c0cc03cdc37188">ToUpperChar</a> (ezUInt32 uiChar)</td></tr>
<tr class="memdesc:aee76481bb274c71041c0cc03cdc37188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the upper case code point for uiChar. <br /></td></tr>
<tr class="separator:aee76481bb274c71041c0cc03cdc37188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9984cd909e423c20869a03847d7ec5"><td class="memItemLeft" align="right" valign="top"><a id="aed9984cd909e423c20869a03847d7ec5"></a>
static ezUInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#aed9984cd909e423c20869a03847d7ec5">ToLowerChar</a> (ezUInt32 uiChar)</td></tr>
<tr class="memdesc:aed9984cd909e423c20869a03847d7ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lower case code point for uiChar. <br /></td></tr>
<tr class="separator:aed9984cd909e423c20869a03847d7ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f700515442b9c61864de2fa3ac81998"><td class="memItemLeft" align="right" valign="top">static ezUInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#a7f700515442b9c61864de2fa3ac81998">ToUpperString</a> (char *szString, const char *pStringEnd=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a7f700515442b9c61864de2fa3ac81998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a (UTF-8) string in-place to upper case.  <a href="../../de/df8/classez_string_utils.htm#a7f700515442b9c61864de2fa3ac81998">More...</a><br /></td></tr>
<tr class="separator:a7f700515442b9c61864de2fa3ac81998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3335c5fa83fe13480e69f4ee8f5c24e8"><td class="memItemLeft" align="right" valign="top">static ezUInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#a3335c5fa83fe13480e69f4ee8f5c24e8">ToLowerString</a> (char *szString, const char *pStringEnd=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a3335c5fa83fe13480e69f4ee8f5c24e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a (UTF-8) string in-place to lower case.  <a href="../../de/df8/classez_string_utils.htm#a3335c5fa83fe13480e69f4ee8f5c24e8">More...</a><br /></td></tr>
<tr class="separator:a3335c5fa83fe13480e69f4ee8f5c24e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc1e5f4336d6f264d95f3917a56dd1e3"><td class="memItemLeft" align="right" valign="top">static ezInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#adc1e5f4336d6f264d95f3917a56dd1e3">CompareChars</a> (ezUInt32 uiCharacter1, ezUInt32 uiCharacter2)</td></tr>
<tr class="memdesc:adc1e5f4336d6f264d95f3917a56dd1e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the two code points for equality.  <a href="../../de/df8/classez_string_utils.htm#adc1e5f4336d6f264d95f3917a56dd1e3">More...</a><br /></td></tr>
<tr class="separator:adc1e5f4336d6f264d95f3917a56dd1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b62f93349a2190bdf90b0249d97302"><td class="memItemLeft" align="right" valign="top">static ezInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#ae5b62f93349a2190bdf90b0249d97302">CompareChars</a> (const char *szUtf8Char1, const char *szUtf8Char2)</td></tr>
<tr class="memdesc:ae5b62f93349a2190bdf90b0249d97302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the first character of each utf8 string for equality.  <a href="../../de/df8/classez_string_utils.htm#ae5b62f93349a2190bdf90b0249d97302">More...</a><br /></td></tr>
<tr class="separator:ae5b62f93349a2190bdf90b0249d97302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778f11d07245c5bc43c6ae7375d11b67"><td class="memItemLeft" align="right" valign="top">static ezInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#a778f11d07245c5bc43c6ae7375d11b67">CompareChars_NoCase</a> (ezUInt32 uiCharacter1, ezUInt32 uiCharacter2)</td></tr>
<tr class="memdesc:a778f11d07245c5bc43c6ae7375d11b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the two code points for equality, case-insensitive.  <a href="../../de/df8/classez_string_utils.htm#a778f11d07245c5bc43c6ae7375d11b67">More...</a><br /></td></tr>
<tr class="separator:a778f11d07245c5bc43c6ae7375d11b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8163a2c94e48aa64550afed054c40584"><td class="memItemLeft" align="right" valign="top">static ezInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#a8163a2c94e48aa64550afed054c40584">CompareChars_NoCase</a> (const char *szUtf8Char1, const char *szUtf8Char2)</td></tr>
<tr class="memdesc:a8163a2c94e48aa64550afed054c40584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the first character of each utf8 string for equality, case-insensitive.  <a href="../../de/df8/classez_string_utils.htm#a8163a2c94e48aa64550afed054c40584">More...</a><br /></td></tr>
<tr class="separator:a8163a2c94e48aa64550afed054c40584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b8c125ced33a6a904f741597ecc673"><td class="memItemLeft" align="right" valign="top"><a id="aa1b8c125ced33a6a904f741597ecc673"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#aa1b8c125ced33a6a904f741597ecc673">IsEqual</a> (const char *pString1, const char *pString2, const char *pString1End=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *pString2End=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:aa1b8c125ced33a6a904f741597ecc673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the two given strings are identical (bitwise). <br /></td></tr>
<tr class="separator:aa1b8c125ced33a6a904f741597ecc673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f8ad413aa294bd530ff0d4dde00654"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#a57f8ad413aa294bd530ff0d4dde00654">IsEqualN</a> (const char *pString1, const char *pString2, ezUInt32 uiCharsToCompare, const char *pString1End=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *pString2End=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a57f8ad413aa294bd530ff0d4dde00654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the two given strings are identical (bitwise) up to the n-th character.  <a href="../../de/df8/classez_string_utils.htm#a57f8ad413aa294bd530ff0d4dde00654">More...</a><br /></td></tr>
<tr class="separator:a57f8ad413aa294bd530ff0d4dde00654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a375be30fe22c27368c0b2801e6c0b0"><td class="memItemLeft" align="right" valign="top"><a id="a5a375be30fe22c27368c0b2801e6c0b0"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#a5a375be30fe22c27368c0b2801e6c0b0">IsEqual_NoCase</a> (const char *pString1, const char *pString2, const char *pString1End=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *pString2End=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a5a375be30fe22c27368c0b2801e6c0b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the two given strings are identical (case-insensitive). <br /></td></tr>
<tr class="separator:a5a375be30fe22c27368c0b2801e6c0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5d6b2aad39e0309d957899b11056e4"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#a5f5d6b2aad39e0309d957899b11056e4">IsEqualN_NoCase</a> (const char *pString1, const char *pString2, ezUInt32 uiCharsToCompare, const char *pString1End=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *pString2End=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a5f5d6b2aad39e0309d957899b11056e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true, if the two given strings are identical (case-insensitive) up to the n-th character.  <a href="../../de/df8/classez_string_utils.htm#a5f5d6b2aad39e0309d957899b11056e4">More...</a><br /></td></tr>
<tr class="separator:a5f5d6b2aad39e0309d957899b11056e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb19aa3ae5704df01d8f7b3649ec8d7"><td class="memItemLeft" align="right" valign="top">static ezInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#acdb19aa3ae5704df01d8f7b3649ec8d7">Compare</a> (const char *pString1, const char *pString2, const char *pString1End=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *pString2End=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:acdb19aa3ae5704df01d8f7b3649ec8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two strings for equality.  <a href="../../de/df8/classez_string_utils.htm#acdb19aa3ae5704df01d8f7b3649ec8d7">More...</a><br /></td></tr>
<tr class="separator:acdb19aa3ae5704df01d8f7b3649ec8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71830c3928036550dbbcf63cb57b737"><td class="memItemLeft" align="right" valign="top">static ezInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#aa71830c3928036550dbbcf63cb57b737">CompareN</a> (const char *pString1, const char *pString2, ezUInt32 uiCharsToCompare, const char *pString1End=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *pString2End=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:aa71830c3928036550dbbcf63cb57b737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the first uiCharsToCompare characters of the two strings for equality.  <a href="../../de/df8/classez_string_utils.htm#aa71830c3928036550dbbcf63cb57b737">More...</a><br /></td></tr>
<tr class="separator:aa71830c3928036550dbbcf63cb57b737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4411d4f7971834bd9ce1fe0cb39b2c39"><td class="memItemLeft" align="right" valign="top">static ezInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#a4411d4f7971834bd9ce1fe0cb39b2c39">Compare_NoCase</a> (const char *pString1, const char *pString2, const char *pString1End=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *pString2End=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a4411d4f7971834bd9ce1fe0cb39b2c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two strings for equality, case-insensitive.  <a href="../../de/df8/classez_string_utils.htm#a4411d4f7971834bd9ce1fe0cb39b2c39">More...</a><br /></td></tr>
<tr class="separator:a4411d4f7971834bd9ce1fe0cb39b2c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e734c728f3ac39fc9f2629dafab2fc6"><td class="memItemLeft" align="right" valign="top">static ezInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#a4e734c728f3ac39fc9f2629dafab2fc6">CompareN_NoCase</a> (const char *pString1, const char *pString2, ezUInt32 uiCharsToCompare, const char *pString1End=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *pString2End=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a4e734c728f3ac39fc9f2629dafab2fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the first uiCharsToCompare characters of the two strings for equality, case-insensitive.  <a href="../../de/df8/classez_string_utils.htm#a4e734c728f3ac39fc9f2629dafab2fc6">More...</a><br /></td></tr>
<tr class="separator:a4e734c728f3ac39fc9f2629dafab2fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ee8e093476b5997362c1bd6a40da71"><td class="memItemLeft" align="right" valign="top">static ezInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#ae1ee8e093476b5997362c1bd6a40da71">snprintf</a> (char *szDst, ezUInt32 uiDstSize, const char *szFormat,...)</td></tr>
<tr class="memdesc:ae1ee8e093476b5997362c1bd6a40da71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a formated string in szDst. uiDstSize defines how many bytes szDst can hold.  <a href="../../de/df8/classez_string_utils.htm#ae1ee8e093476b5997362c1bd6a40da71">More...</a><br /></td></tr>
<tr class="separator:ae1ee8e093476b5997362c1bd6a40da71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d171defbd9f803f3588951d7a8e098"><td class="memItemLeft" align="right" valign="top">static ezInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#a54d171defbd9f803f3588951d7a8e098">vsnprintf</a> (char *szDst, ezUInt32 uiDstSize, const char *szFormat, va_list ap)</td></tr>
<tr class="memdesc:a54d171defbd9f803f3588951d7a8e098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a formated string in szDst. uiDstSize defines how many bytes szDst can hold.  <a href="../../de/df8/classez_string_utils.htm#a54d171defbd9f803f3588951d7a8e098">More...</a><br /></td></tr>
<tr class="separator:a54d171defbd9f803f3588951d7a8e098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b418cc21bcbebde0942157e9026d2a4"><td class="memItemLeft" align="right" valign="top"><a id="a7b418cc21bcbebde0942157e9026d2a4"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#a7b418cc21bcbebde0942157e9026d2a4">StartsWith</a> (const char *szString, const char *szStartsWith, const char *pStringEnd=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *szStartsWithEnd=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a7b418cc21bcbebde0942157e9026d2a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if szString starts with the string given in szStartsWith. <br /></td></tr>
<tr class="separator:a7b418cc21bcbebde0942157e9026d2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a76bb518ebebf3971f367a478a387c3"><td class="memItemLeft" align="right" valign="top"><a id="a9a76bb518ebebf3971f367a478a387c3"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#a9a76bb518ebebf3971f367a478a387c3">StartsWith_NoCase</a> (const char *szString, const char *szStartsWith, const char *pStringEnd=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *szStartsWithEnd=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a9a76bb518ebebf3971f367a478a387c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if szString starts with the string given in szStartsWith. Ignores case. <br /></td></tr>
<tr class="separator:a9a76bb518ebebf3971f367a478a387c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347b438581d998a7ae158c57ceca1adf"><td class="memItemLeft" align="right" valign="top"><a id="a347b438581d998a7ae158c57ceca1adf"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#a347b438581d998a7ae158c57ceca1adf">EndsWith</a> (const char *szString, const char *szEndsWith, const char *pStringEnd=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *szEndsWithEnd=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a347b438581d998a7ae158c57ceca1adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if szString ends with the string given in szEndsWith. <br /></td></tr>
<tr class="separator:a347b438581d998a7ae158c57ceca1adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bea564b8ddd615f8b24886ae566397"><td class="memItemLeft" align="right" valign="top"><a id="a22bea564b8ddd615f8b24886ae566397"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#a22bea564b8ddd615f8b24886ae566397">EndsWith_NoCase</a> (const char *szString, const char *szEndsWith, const char *pStringEnd=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *szEndsWithEnd=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a22bea564b8ddd615f8b24886ae566397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if szString ends with the string given in szEndsWith. Ignores case. <br /></td></tr>
<tr class="separator:a22bea564b8ddd615f8b24886ae566397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7bb80c9b5b1bc468d88e70379895ff"><td class="memItemLeft" align="right" valign="top"><a id="a4e7bb80c9b5b1bc468d88e70379895ff"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#a4e7bb80c9b5b1bc468d88e70379895ff">FindSubString</a> (const char *szSource, const char *szStringToFind, const char *pSourceEnd=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *szStringToFindEnd=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a4e7bb80c9b5b1bc468d88e70379895ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the first occurrence of szStringToFind in szSource. <br /></td></tr>
<tr class="separator:a4e7bb80c9b5b1bc468d88e70379895ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7fbe5b887c01f627ca3336109a99c8"><td class="memItemLeft" align="right" valign="top"><a id="a0f7fbe5b887c01f627ca3336109a99c8"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#a0f7fbe5b887c01f627ca3336109a99c8">FindSubString_NoCase</a> (const char *szSource, const char *szStringToFind, const char *pSourceEnd=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *szStringToFindEnd=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a0f7fbe5b887c01f627ca3336109a99c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the first occurrence of szStringToFind in szSource. Ignores case. <br /></td></tr>
<tr class="separator:a0f7fbe5b887c01f627ca3336109a99c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340e032eb32b1e5b4c3461f52e7088e5"><td class="memItemLeft" align="right" valign="top"><a id="a340e032eb32b1e5b4c3461f52e7088e5"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#a340e032eb32b1e5b4c3461f52e7088e5">FindLastSubString</a> (const char *szSource, const char *szStringToFind, const char *szStartSearchAt=nullptr, const char *pSourceEnd=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *szStringToFindEnd=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a340e032eb32b1e5b4c3461f52e7088e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the last occurrence of szStringToFind in szSource before szStartSearchAt. <br /></td></tr>
<tr class="separator:a340e032eb32b1e5b4c3461f52e7088e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32404acfb618abe38094ecddb19ff4b8"><td class="memItemLeft" align="right" valign="top"><a id="a32404acfb618abe38094ecddb19ff4b8"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#a32404acfb618abe38094ecddb19ff4b8">FindLastSubString_NoCase</a> (const char *szSource, const char *szStringToFind, const char *szStartSearchAt=nullptr, const char *pSourceEnd=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;(), const char *szStringToFindEnd=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a32404acfb618abe38094ecddb19ff4b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the last occurrence of szStringToFind in szSource before szStartSearchAt. Ignores case. <br /></td></tr>
<tr class="separator:a32404acfb618abe38094ecddb19ff4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d7e96d2a10e2bf564a88a67a99761d"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#aa8d7e96d2a10e2bf564a88a67a99761d">SkipCharacters</a> (const char *szString, <a class="el" href="../../de/df8/classez_string_utils.htm#a30a256e58c74618a988775c15bdd3d8e">EZ_CHARACTER_FILTER</a> SkipCharacterCB, bool bAlwaysSkipFirst=false)</td></tr>
<tr class="memdesc:aa8d7e96d2a10e2bf564a88a67a99761d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts at szString and advances to the next character for which SkipCharacterCB returns false;.  <a href="../../de/df8/classez_string_utils.htm#aa8d7e96d2a10e2bf564a88a67a99761d">More...</a><br /></td></tr>
<tr class="separator:aa8d7e96d2a10e2bf564a88a67a99761d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a71521d5e97ef262587ca5c9af5d973"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#a1a71521d5e97ef262587ca5c9af5d973">FindWordEnd</a> (const char *szString, <a class="el" href="../../de/df8/classez_string_utils.htm#a30a256e58c74618a988775c15bdd3d8e">EZ_CHARACTER_FILTER</a> IsDelimiterCB, bool bAlwaysSkipFirst=true)</td></tr>
<tr class="memdesc:a1a71521d5e97ef262587ca5c9af5d973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position in szString at which <em>IsDelimiterCB</em> returns true.  <a href="../../de/df8/classez_string_utils.htm#a1a71521d5e97ef262587ca5c9af5d973">More...</a><br /></td></tr>
<tr class="separator:a1a71521d5e97ef262587ca5c9af5d973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4a5d8e85c08a0df5d8a555675c9cb5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#a0f4a5d8e85c08a0df5d8a555675c9cb5">Trim</a> (const char *&amp;pString, const char *&amp;pStringEnd, const char *szTrimCharsStart, const char *szTrimCharsEnd)</td></tr>
<tr class="memdesc:a0f4a5d8e85c08a0df5d8a555675c9cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all characters at the start and end of the string that match the respective characters and updates the new start and end of the string.  <a href="../../de/df8/classez_string_utils.htm#a0f4a5d8e85c08a0df5d8a555675c9cb5">More...</a><br /></td></tr>
<tr class="separator:a0f4a5d8e85c08a0df5d8a555675c9cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45e6f8223ffe3b8deb634c1abd76dd4"><td class="memItemLeft" align="right" valign="top"><a id="ab45e6f8223ffe3b8deb634c1abd76dd4"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#ab45e6f8223ffe3b8deb634c1abd76dd4">IsWhiteSpace</a> (ezUInt32 uiChar)</td></tr>
<tr class="memdesc:ab45e6f8223ffe3b8deb634c1abd76dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default word delimiter function that returns true for ' ' (space), '\r' (carriage return), '<br  />
' (newline), '\t' (tab) and '\v' (vertical tab) <br /></td></tr>
<tr class="separator:ab45e6f8223ffe3b8deb634c1abd76dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2fae057901d43291615cc5c79774aa2"><td class="memItemLeft" align="right" valign="top"><a id="af2fae057901d43291615cc5c79774aa2"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#af2fae057901d43291615cc5c79774aa2">IsDecimalDigit</a> (ezUInt32 uiChar)</td></tr>
<tr class="memdesc:af2fae057901d43291615cc5c79774aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A decimal digit from 0..9. <br /></td></tr>
<tr class="separator:af2fae057901d43291615cc5c79774aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c4ab5994560540785660a76abfcf47"><td class="memItemLeft" align="right" valign="top"><a id="a15c4ab5994560540785660a76abfcf47"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#a15c4ab5994560540785660a76abfcf47">IsHexDigit</a> (ezUInt32 uiChar)</td></tr>
<tr class="memdesc:a15c4ab5994560540785660a76abfcf47"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hexadecimal digit from 0..F. <br /></td></tr>
<tr class="separator:a15c4ab5994560540785660a76abfcf47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3331fba4a431cb5b5e307ffe4620fff8"><td class="memItemLeft" align="right" valign="top"><a id="a3331fba4a431cb5b5e307ffe4620fff8"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#a3331fba4a431cb5b5e307ffe4620fff8">IsWordDelimiter_English</a> (ezUInt32 uiChar)</td></tr>
<tr class="memdesc:a3331fba4a431cb5b5e307ffe4620fff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default word delimiter function for English text. <br /></td></tr>
<tr class="separator:a3331fba4a431cb5b5e307ffe4620fff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959b606019029e8661af4b5e4ba0440f"><td class="memItemLeft" align="right" valign="top"><a id="a959b606019029e8661af4b5e4ba0440f"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#a959b606019029e8661af4b5e4ba0440f">IsIdentifierDelimiter_C_Code</a> (ezUInt32 uiChar)</td></tr>
<tr class="memdesc:a959b606019029e8661af4b5e4ba0440f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default word delimiter function for identifiers in C code. <br /></td></tr>
<tr class="separator:a959b606019029e8661af4b5e4ba0440f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1997081fbfa0fb44deccd0bc48f3b047"><td class="memItemLeft" align="right" valign="top"><a id="a1997081fbfa0fb44deccd0bc48f3b047"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#a1997081fbfa0fb44deccd0bc48f3b047">IsValidIdentifierName</a> (const char *pString, const char *pStringEnd=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a1997081fbfa0fb44deccd0bc48f3b047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the given string is a valid identifier name in C code, ie has no white-spaces, starts with a literal etc. <br /></td></tr>
<tr class="separator:a1997081fbfa0fb44deccd0bc48f3b047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0719f9e3c4489652aa7d94ed08accce"><td class="memItemLeft" align="right" valign="top"><a id="ad0719f9e3c4489652aa7d94ed08accce"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#ad0719f9e3c4489652aa7d94ed08accce">FindWholeWord</a> (const char *szString, const char *szSearchFor, <a class="el" href="../../de/df8/classez_string_utils.htm#a30a256e58c74618a988775c15bdd3d8e">EZ_CHARACTER_FILTER</a> IsDelimiterCB, const char *pStringEnd=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:ad0719f9e3c4489652aa7d94ed08accce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches szString for the word szSearchFor. If IsDelimiterCB returns true for both characters in front and back of the word, the position is returned. Otherwise nullptr. <br /></td></tr>
<tr class="separator:ad0719f9e3c4489652aa7d94ed08accce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4229ff45b413b9221fb12d377f353be5"><td class="memItemLeft" align="right" valign="top"><a id="a4229ff45b413b9221fb12d377f353be5"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#a4229ff45b413b9221fb12d377f353be5">FindWholeWord_NoCase</a> (const char *szString, const char *szSearchFor, <a class="el" href="../../de/df8/classez_string_utils.htm#a30a256e58c74618a988775c15bdd3d8e">EZ_CHARACTER_FILTER</a> IsDelimiterCB, const char *pStringEnd=<a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt; char &gt;())</td></tr>
<tr class="memdesc:a4229ff45b413b9221fb12d377f353be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches szString for the word szSearchFor. If IsDelimiterCB returns true for both characters in front and back of the word, the position is returned. Otherwise nullptr. Ignores case. <br /></td></tr>
<tr class="separator:a4229ff45b413b9221fb12d377f353be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7530ec208361d72eb88750cdade3c3"><td class="memItemLeft" align="right" valign="top"><a id="acc7530ec208361d72eb88750cdade3c3"></a>
static <a class="el" href="../../d4/da9/structez_result.htm">ezResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#acc7530ec208361d72eb88750cdade3c3">FindUIntAtTheEnd</a> (const char *szString, ezUInt32 &amp;out_uiValue, ezUInt32 *pStringLengthBeforeUInt=nullptr)</td></tr>
<tr class="memdesc:acc7530ec208361d72eb88750cdade3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given szString ends with an unsigned integer (e.g. "MyString123"). If pStringLengthBeforeUInt is non-null the string length up to the first digit is stored. Returns EZ_SUCCESS if there is a value at the end of string, EZ_FAILURE otherwise. <br /></td></tr>
<tr class="separator:acc7530ec208361d72eb88750cdade3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97904160085b90a002266630affda46"><td class="memItemLeft" align="right" valign="top"><a id="ac97904160085b90a002266630affda46"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#ac97904160085b90a002266630affda46">OutputFormattedInt</a> (char *szOutputBuffer, ezUInt32 uiBufferSize, ezUInt32 &amp;uiWritePos, ezInt64 value, ezUInt8 uiWidth, bool bPadZeros, ezUInt8 uiBase)</td></tr>
<tr class="memdesc:ac97904160085b90a002266630affda46"><td class="mdescLeft">&#160;</td><td class="mdescRight">[internal] Prefer to use snprintf. <br /></td></tr>
<tr class="separator:ac97904160085b90a002266630affda46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06866ead1156c5d7e506ea7555a0fc2"><td class="memItemLeft" align="right" valign="top"><a id="ab06866ead1156c5d7e506ea7555a0fc2"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#ab06866ead1156c5d7e506ea7555a0fc2">OutputFormattedUInt</a> (char *szOutputBuffer, ezUInt32 uiBufferSize, ezUInt32 &amp;uiWritePos, ezUInt64 value, ezUInt8 uiWidth, bool bPadZeros, ezUInt8 uiBase, bool bUpperCase)</td></tr>
<tr class="memdesc:ab06866ead1156c5d7e506ea7555a0fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">[internal] Prefer to use snprintf. <br /></td></tr>
<tr class="separator:ab06866ead1156c5d7e506ea7555a0fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8bfe79bf3c76501a0a1034bb2f549a"><td class="memItemLeft" align="right" valign="top"><a id="a9b8bfe79bf3c76501a0a1034bb2f549a"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df8/classez_string_utils.htm#a9b8bfe79bf3c76501a0a1034bb2f549a">OutputFormattedFloat</a> (char *szOutputBuffer, ezUInt32 uiBufferSize, ezUInt32 &amp;uiWritePos, double value, ezUInt8 uiWidth, bool bPadZeros, ezInt8 iPrecision, bool bScientific, bool bRemoveTrailingZeroes=false)</td></tr>
<tr class="memdesc:a9b8bfe79bf3c76501a0a1034bb2f549a"><td class="mdescLeft">&#160;</td><td class="mdescRight">[internal] Prefer to use snprintf. <br /></td></tr>
<tr class="separator:a9b8bfe79bf3c76501a0a1034bb2f549a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2da66c56613e691e5de0fc72ee6fbf"><td class="memItemLeft" align="right" valign="top"><a id="a4f2da66c56613e691e5de0fc72ee6fbf"></a>
static EZ_ALWAYS_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>AddUsedStringLength</b> (ezUInt32)</td></tr>
<tr class="separator:a4f2da66c56613e691e5de0fc72ee6fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8ed5a0372f69a3d167af3ef51d05c3"><td class="memItemLeft" align="right" valign="top"><a id="acf8ed5a0372f69a3d167af3ef51d05c3"></a>
static EZ_ALWAYS_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>PrintStringLengthStatistics</b> ()</td></tr>
<tr class="separator:acf8ed5a0372f69a3d167af3ef51d05c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Helper functions to work with UTF-8 strings (which include pure ASCII strings) </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="acdb19aa3ae5704df01d8f7b3649ec8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb19aa3ae5704df01d8f7b3649ec8d7">&#9670;&nbsp;</a></span>Compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ezInt32 ezStringUtils::Compare </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString1End</em> = <code><a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString2End</em> = <code><a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two strings for equality. </p>
<p>Returns a negative number if the pString1 is 'smaller' or shorter than pString2. Returns a positive number, if pString1 is 'larger' or longer than pString1. Returns 0 for equal strings. Works with UTF-8 strings as well. </p>

</div>
</div>
<a id="a4411d4f7971834bd9ce1fe0cb39b2c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4411d4f7971834bd9ce1fe0cb39b2c39">&#9670;&nbsp;</a></span>Compare_NoCase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ezInt32 ezStringUtils::Compare_NoCase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString1End</em> = <code><a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString2End</em> = <code><a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two strings for equality, case-insensitive. </p>
<p>Returns a negative number if the pString1 is 'smaller' or shorter than pString2. Returns a positive number, if pString1 is 'larger' or longer than pString1. Returns 0 for equal strings. Works with UTF-8 strings as well. </p>

</div>
</div>
<a id="ae5b62f93349a2190bdf90b0249d97302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b62f93349a2190bdf90b0249d97302">&#9670;&nbsp;</a></span>CompareChars() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ezInt32 ezStringUtils::CompareChars </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szUtf8Char1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szUtf8Char2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the first character of each utf8 string for equality. </p>
<p>Returns a negative number, if szUtf8Char1 is smaller than szUtf8Char2. Returns a positive number, if szUtf8Char1 is larger than szUtf8Char2. Returns 0 if both are equal. </p>

</div>
</div>
<a id="adc1e5f4336d6f264d95f3917a56dd1e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc1e5f4336d6f264d95f3917a56dd1e3">&#9670;&nbsp;</a></span>CompareChars() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EZ_ALWAYS_INLINE ezInt32 ezStringUtils::CompareChars </td>
          <td>(</td>
          <td class="paramtype">ezUInt32&#160;</td>
          <td class="paramname"><em>uiCharacter1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ezUInt32&#160;</td>
          <td class="paramname"><em>uiCharacter2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the two code points for equality. </p>
<p>Returns a negative number, if uiCharacter1 is smaller than uiCharacter2. Returns a positive number, if uiCharacter1 is larger than uiCharacter2. Returns 0 if both are equal. </p>

</div>
</div>
<a id="a8163a2c94e48aa64550afed054c40584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8163a2c94e48aa64550afed054c40584">&#9670;&nbsp;</a></span>CompareChars_NoCase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ezInt32 ezStringUtils::CompareChars_NoCase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szUtf8Char1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szUtf8Char2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the first character of each utf8 string for equality, case-insensitive. </p>
<p>Returns a negative number, if szUtf8Char1 is smaller than szUtf8Char2. Returns a positive number, if szUtf8Char1 is larger than szUtf8Char2. Returns 0 if both are equal. </p>

</div>
</div>
<a id="a778f11d07245c5bc43c6ae7375d11b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778f11d07245c5bc43c6ae7375d11b67">&#9670;&nbsp;</a></span>CompareChars_NoCase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ezInt32 ezStringUtils::CompareChars_NoCase </td>
          <td>(</td>
          <td class="paramtype">ezUInt32&#160;</td>
          <td class="paramname"><em>uiCharacter1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ezUInt32&#160;</td>
          <td class="paramname"><em>uiCharacter2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the two code points for equality, case-insensitive. </p>
<p>Returns a negative number, if uiCharacter1 is smaller than uiCharacter2. Returns a positive number, if uiCharacter1 is larger than uiCharacter2. Returns 0 if both are equal. </p>

</div>
</div>
<a id="aa71830c3928036550dbbcf63cb57b737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa71830c3928036550dbbcf63cb57b737">&#9670;&nbsp;</a></span>CompareN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ezInt32 ezStringUtils::CompareN </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ezUInt32&#160;</td>
          <td class="paramname"><em>uiCharsToCompare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString1End</em> = <code><a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString2End</em> = <code><a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the first uiCharsToCompare characters of the two strings for equality. </p>
<p>Returns a negative number if the pString1 is 'smaller' or shorter than pString2. Returns a positive number, if pString1 is 'larger' or longer than pString1. Returns 0 for equal strings. Works with UTF-8 strings as well. </p>

</div>
</div>
<a id="a4e734c728f3ac39fc9f2629dafab2fc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e734c728f3ac39fc9f2629dafab2fc6">&#9670;&nbsp;</a></span>CompareN_NoCase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ezInt32 ezStringUtils::CompareN_NoCase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ezUInt32&#160;</td>
          <td class="paramname"><em>uiCharsToCompare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString1End</em> = <code><a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString2End</em> = <code><a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the first uiCharsToCompare characters of the two strings for equality, case-insensitive. </p>
<p>Returns a negative number if the pString1 is 'smaller' or shorter than pString2. Returns a positive number, if pString1 is 'larger' or longer than pString1. Returns 0 for equal strings. Works with UTF-8 strings as well. </p>

</div>
</div>
<a id="a193ae00236c80eb4aa25942bcc2d71d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193ae00236c80eb4aa25942bcc2d71d2">&#9670;&nbsp;</a></span>Copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ezUInt32 ezStringUtils::Copy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>szDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ezUInt32&#160;</td>
          <td class="paramname"><em>uiDstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pSourceEnd</em> = <code><a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the string from szSource into the given buffer, which can hold at least uiDstSize bytes. </p>
<p>The string will always be \0 terminated. Multi-byte UTF-8 characters will only be copied, if they can fit completely into szDest. I.e. they will be truncated at a character boundary. Returns the number of bytes that were copied into szDest, excluding the terminating \0 </p>

</div>
</div>
<a id="a586a009ed403d13479d284f3d1ef0f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a586a009ed403d13479d284f3d1ef0f7f">&#9670;&nbsp;</a></span>CopyN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ezUInt32 ezStringUtils::CopyN </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>szDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ezUInt32&#160;</td>
          <td class="paramname"><em>uiDstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ezUInt32&#160;</td>
          <td class="paramname"><em>uiCharsToCopy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pSourceEnd</em> = <code><a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies up to uiCharsToCopy characters into the given buffer, which can hold at least uiDstSize bytes. </p>
<p>The string will always be \0 terminated. Multi-byte UTF-8 characters will only be copied, if they can fit completely into szDest. I.e. they will be truncated at a character boundary. Returns the number of bytes that were copied into szDest, excluding the terminating \0 </p>

</div>
</div>
<a id="a1a71521d5e97ef262587ca5c9af5d973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a71521d5e97ef262587ca5c9af5d973">&#9670;&nbsp;</a></span>FindWordEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * ezStringUtils::FindWordEnd </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/df8/classez_string_utils.htm#a30a256e58c74618a988775c15bdd3d8e">EZ_CHARACTER_FILTER</a>&#160;</td>
          <td class="paramname"><em>IsDelimiterCB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAlwaysSkipFirst</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position in szString at which <em>IsDelimiterCB</em> returns true. </p>
<p>This is basically the inverse of SkipCharacters. SkipCharacters advances over all characters that fulfill the filter, FindWordEnd advances over all characters that do not fulfill it. </p>

</div>
</div>
<a id="ac50e765fba05ee2f920e3334982eb352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac50e765fba05ee2f920e3334982eb352">&#9670;&nbsp;</a></span>GetStringElementCount() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ezUInt32 ezStringUtils::GetStringElementCount </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pString</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements of type T that the string contains, until it hits an element that is zero OR until it hits the end pointer. </p>
<p>Equal to the string length, if used with pure ASCII strings. Equal to the amount of bytes in a string, if used on non-ASCII (i.e. UTF-8) strings. Equal to the number of characters in a string, if used with UTF-32 strings. </p>

</div>
</div>
<a id="a4dfad40f09f4815168a05bfd5ed65242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dfad40f09f4815168a05bfd5ed65242">&#9670;&nbsp;</a></span>GetStringElementCount() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ezUInt32 ezStringUtils::GetStringElementCount </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>pStringEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements of type T that the string contains, until it hits an element that is zero OR until it hits the end pointer. </p>
<p>Equal to the string length, if used with pure ASCII strings. Equal to the amount of bytes in a string, if used on non-ASCII (i.e. UTF-8) strings. Equal to the number of characters in a string, if used with UTF-32 strings. </p>

</div>
</div>
<a id="a57f8ad413aa294bd530ff0d4dde00654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f8ad413aa294bd530ff0d4dde00654">&#9670;&nbsp;</a></span>IsEqualN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EZ_ALWAYS_INLINE bool ezStringUtils::IsEqualN </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ezUInt32&#160;</td>
          <td class="paramname"><em>uiCharsToCompare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString1End</em> = <code><a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString2End</em> = <code><a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true, if the two given strings are identical (bitwise) up to the n-th character. </p>
<p>This function will handle UTF-8 strings properly. </p>

</div>
</div>
<a id="a5f5d6b2aad39e0309d957899b11056e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f5d6b2aad39e0309d957899b11056e4">&#9670;&nbsp;</a></span>IsEqualN_NoCase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EZ_ALWAYS_INLINE bool ezStringUtils::IsEqualN_NoCase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ezUInt32&#160;</td>
          <td class="paramname"><em>uiCharsToCompare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString1End</em> = <code><a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pString2End</em> = <code><a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true, if the two given strings are identical (case-insensitive) up to the n-th character. </p>
<p>This function will handle UTF-8 strings properly. </p>

</div>
</div>
<a id="aa8d7e96d2a10e2bf564a88a67a99761d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d7e96d2a10e2bf564a88a67a99761d">&#9670;&nbsp;</a></span>SkipCharacters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * ezStringUtils::SkipCharacters </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/df8/classez_string_utils.htm#a30a256e58c74618a988775c15bdd3d8e">EZ_CHARACTER_FILTER</a>&#160;</td>
          <td class="paramname"><em>SkipCharacterCB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAlwaysSkipFirst</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts at szString and advances to the next character for which SkipCharacterCB returns false;. </p>
<p>If <em>bAlwaysSkipFirst</em> is false and szString points to a character that does not fulfill the filter, this function will return immediately and nothing will change. If <em>bAlwaysSkipFirst</em> is true, the first character will always be skipped, regardless what it is (unless it is the zero terminator). The latter is useful to skip an entire word and get to the next word in a string.<br  />
 </p>

</div>
</div>
<a id="ae1ee8e093476b5997362c1bd6a40da71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ee8e093476b5997362c1bd6a40da71">&#9670;&nbsp;</a></span>snprintf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ezStringUtils::snprintf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>szDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ezUInt32&#160;</td>
          <td class="paramname"><em>uiDstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a formated string in szDst. uiDstSize defines how many bytes szDst can hold. </p>
<p>Returns the number of bytes that would have been required to output the entire string (excluding the 0 terminator).<br  />
Returns -1 if an error occurred. In this case it might also write a more detailed error message to the destination string itself. szDst may be nullptr.<br  />
uiDstSize may be zero.<br  />
This can be used to query how much storage is required, then allocate it and call snprintf again to fill it.<br  />
Formatting works exactly like printf, except that it additionally supports outputting binary with the 'b' modifier and it will output float NaN and Infinity as proper text. </p>

</div>
</div>
<a id="a3335c5fa83fe13480e69f4ee8f5c24e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3335c5fa83fe13480e69f4ee8f5c24e8">&#9670;&nbsp;</a></span>ToLowerString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ezUInt32 ezStringUtils::ToLowerString </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>szString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pStringEnd</em> = <code><a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a (UTF-8) string in-place to lower case. </p>
<p>Returns the new string length in bytes (it might shrink, but never grow), excluding the \0 terminator. </p>

</div>
</div>
<a id="a7f700515442b9c61864de2fa3ac81998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f700515442b9c61864de2fa3ac81998">&#9670;&nbsp;</a></span>ToUpperString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ezUInt32 ezStringUtils::ToUpperString </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>szString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pStringEnd</em> = <code><a class="el" href="../../d9/d32/classez_unicode_utils.htm#a580463d2f8474b7119639fa86104cb93">ezUnicodeUtils::GetMaxStringEnd</a>&lt;char&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a (UTF-8) string in-place to upper case. </p>
<p>Returns the new string length in bytes (it might shrink, but never grow), excluding the \0 terminator. </p>

</div>
</div>
<a id="a0f4a5d8e85c08a0df5d8a555675c9cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f4a5d8e85c08a0df5d8a555675c9cb5">&#9670;&nbsp;</a></span>Trim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ezStringUtils::Trim </td>
          <td>(</td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>pString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>pStringEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szTrimCharsStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szTrimCharsEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all characters at the start and end of the string that match the respective characters and updates the new start and end of the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pString</td><td>The string to trim. </td></tr>
    <tr><td class="paramname">pStringEnd</td><td>The end pointer into pString, either the end pointer for the not zero terminated string or ezMaxStringEnd for zero terminated ones.</td></tr>
    <tr><td class="paramname">szTrimCharsStart</td><td>A string compromised of characters to trim from the start of the string.</td></tr>
    <tr><td class="paramname">szTrimCharsEnd</td><td>A string compromised of characters to trim from the end of the string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54d171defbd9f803f3588951d7a8e098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54d171defbd9f803f3588951d7a8e098">&#9670;&nbsp;</a></span>vsnprintf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ezStringUtils::vsnprintf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>szDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ezUInt32&#160;</td>
          <td class="paramname"><em>uiDstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a formated string in szDst. uiDstSize defines how many bytes szDst can hold. </p>
<p>Returns the number of bytes that would have been required to output the entire string (excluding the 0 terminator).<br  />
Returns -1 if an error occurred. In this case it might also write a more detailed error message to the destination string itself. szDst may be nullptr.<br  />
uiDstSize may be zero.<br  />
This can be used to query how much storage is required, then allocate it and call snprintf again to fill it.<br  />
Formatting works exactly like printf, except that it additionally supports outputting binary with the 'b' modifier and it will output float NaN and Infinity as proper text. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/ezEngine/ezEngine/Code/Engine/Foundation/Strings/<a class="el" href="../../de/dde/_string_utils_8h_source.htm">StringUtils.h</a></li>
<li>/home/runner/work/ezEngine/ezEngine/Code/Engine/Foundation/Strings/Implementation/snprintf.cpp</li>
<li>/home/runner/work/ezEngine/ezEngine/Code/Engine/Foundation/Strings/Implementation/StringUtils.cpp</li>
<li>/home/runner/work/ezEngine/ezEngine/Code/Engine/Foundation/Strings/Implementation/<a class="el" href="../../d4/d13/_string_utils__inl_8h_source.htm">StringUtils_inl.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../de/df8/classez_string_utils.htm">ezStringUtils</a></li>
    <li class="footer">Generated on Sun Oct 9 2022 14:45:09 for ezEngine by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
